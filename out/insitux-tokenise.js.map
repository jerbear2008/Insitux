{"version":3,"file":"insitux-tokenise.js","mappings":"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","sources":["webpack://insituxTokenise/webpack/bootstrap","webpack://insituxTokenise/webpack/runtime/define property getters","webpack://insituxTokenise/webpack/runtime/hasOwnProperty shorthand","webpack://insituxTokenise/webpack/runtime/make namespace object","webpack://insituxTokenise/./src/poly-fills.ts","webpack://insituxTokenise/./src/parse.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const toNum = (x: unknown): number => Number(x); //Should also support 0b and 0x\r\nexport const slice = <T>(arr: T[], start?: number, end?: number): T[] =>\r\n  arr.slice(start, end);\r\nexport const splice = <T>(arr: T[], start: number, numDel?: number): T[] =>\r\n  arr.splice(start, numDel);\r\nexport const len = <T>(arr: T[]): number => arr.length;\r\nexport const slen = (str: string): number => str.length;\r\nexport const isNum = (x: unknown): x is number =>\r\n  x !== \"\" && !Number.isNaN(Number(x));\r\nexport const isArray = <T>(x: unknown): x is T[] => Array.isArray(x);\r\nexport const substr = (str: string, start: number, length?: number): string =>\r\n  str.substring(start, start + (length ?? str.length));\r\nexport const strIdx = (str: string, idx: number): string => str[idx];\r\nexport const sub = (x: string, s: string): boolean => x.includes(s);\r\nexport const subIdx = (x: string, s: string) => x.indexOf(s);\r\nexport const has = <T>(x: T[], y: T): boolean => x.includes(y);\r\nexport const starts = (str: string, prefix: string): boolean =>\r\n  str.startsWith(prefix);\r\nexport const ends = (str: string, x: string): boolean => str.endsWith(x);\r\nexport const replace = (str: string, what: string, to: string): string =>\r\n  str.replace(new RegExp(what, \"g\"), to);\r\nexport const flat = <T>(arr: T[][]): T[] => arr.flat(); //e.g. [[0], [1], []] => [0, 1]\r\nexport const concat = <T>(a: T[], b: T[]): T[] => a.concat(b);\r\nexport const push = <T>(arr: T[], add: T[]) => arr.push(...add);\r\nexport const sortBy = <T>(arr: T[], by: (a: T, b: T) => number) => arr.sort(by);\r\nexport const reverse = <T>(arr: T[]) => arr.reverse();\r\nexport const lowerCase = (str: string) => str.toLowerCase();\r\nexport const upperCase = (str: string) => str.toUpperCase();\r\nexport const trim = (str: string) => str.trim();\r\nexport const trimStart = (str: string) => str.trimStart();\r\nexport const trimEnd = (str: string) => str.trimEnd();\r\nexport const padEnd = (str: string, by: number) => str.padEnd(by);\r\nexport const charCode = (str: string): number => str.charCodeAt(0);\r\nexport const codeChar = (num: number): string => String.fromCharCode(num);\r\nexport const randNum = (a: number, b: number) => a + Math.random() * (b - a);\r\nexport const randInt = (a: number, b: number) => Math.floor(randNum(a, b));\r\nexport const range = (len: number) => [...Array(len).keys()];\r\nexport const objKeys = (x: object) => Object.keys(x);\r\nexport const getTimeMs = () => new Date().getTime();\r\nexport const abs = Math.abs;\r\nexport const min = Math.min;\r\nexport const max = Math.max;\r\nexport const sin = Math.sin;\r\nexport const cos = Math.cos;\r\nexport const tan = Math.tan;\r\nexport const sinh = Math.sinh;\r\nexport const cosh = Math.cosh;\r\nexport const tanh = Math.tanh;\r\nexport const asin = Math.asin;\r\nexport const acos = Math.acos;\r\nexport const atan = Math.atan;\r\nexport const sqrt = Math.sqrt;\r\nexport const round = Math.round;\r\nexport const floor = Math.floor;\r\nexport const ceil = Math.ceil;\r\nexport const sign = Math.sign;\r\nexport const logn = Math.log;\r\nexport const log2 = Math.log2;\r\nexport const log10 = Math.log10;\r\n","import { arityCheck, keyOpErr, numOpErr, typeCheck } from \"./checks\";\r\nimport { makeClosure } from \"./closure\";\r\nimport * as pf from \"./poly-fills\";\r\nconst { has, flat, push, slice, splice } = pf;\r\nconst { slen, starts, sub, substr, strIdx, subIdx } = pf;\r\nconst { isNum, len, toNum } = pf;\r\nimport { ParamsShape, Func, Funcs, Ins, ops, Val, syntaxes } from \"./types\";\r\nimport { assertUnreachable, InvokeError, ErrCtx } from \"./types\";\r\n\r\nexport type Token = {\r\n  typ: \"str\" | \"num\" | \"sym\" | \"rem\" | \"(\" | \")\";\r\n  text: string;\r\n  errCtx: ErrCtx;\r\n};\r\ntype Node = Token | Node[];\r\ntype ParserIns = Ins | { typ: \"err\"; value: string; errCtx: ErrCtx };\r\nconst nullVal: Val = { t: \"null\", v: undefined };\r\nconst falseVal = <Val>{ t: \"bool\", v: false };\r\ntype NamedNodes = {\r\n  name: string;\r\n  nodes: Node[];\r\n};\r\nconst isToken = (node: Node | undefined): node is Token =>\r\n  !!node && \"errCtx\" in node;\r\nconst symAt = (node: Node, pos = 0) => {\r\n  if (isToken(node)) {\r\n    return \"\";\r\n  }\r\n  const arg = node[pos];\r\n  return (isToken(arg) && has([\"sym\", \"str\"], arg.typ) && arg.text) || \"\";\r\n};\r\nconst token2str = ({ typ, text }: Token): string =>\r\n  typ === \"str\" ? `\"${text}\"` : text;\r\nfunction node2str(nodes: Node[]): string {\r\n  const sym0 = symAt(nodes, 0);\r\n  const isClosure = has([\"#\", \"@\"], sym0);\r\n  if (isClosure) {\r\n    nodes = slice(nodes, 1);\r\n  }\r\n  return `${isClosure ? sym0 : \"\"}(${nodes\r\n    .map(n => (isToken(n) ? token2str(n) : node2str(n)))\r\n    .join(\" \")})`;\r\n}\r\n\r\n/** Inserts pop instruction after penultimate body expression */\r\nconst poppedBody = (expressions: ParserIns[][]): ParserIns[] => {\r\n  if (len(expressions) === 1) {\r\n    return flat(expressions);\r\n  }\r\n  const lastExp = expressions[len(expressions) - 1];\r\n  const truncatedExps = slice(expressions, 0, len(expressions) - 1);\r\n  const popIns = <ParserIns>{\r\n    typ: \"pop\",\r\n    value: len(truncatedExps),\r\n    errCtx: lastExp[0].errCtx,\r\n  };\r\n  return flat([...truncatedExps, [popIns], lastExp]);\r\n};\r\n\r\nexport function tokenise(\r\n  code: string,\r\n  invokeId: string,\r\n  doTransforms = true,\r\n  emitComments = false,\r\n) {\r\n  const tokens: Token[] = [];\r\n  const isDigit = (ch: string) => sub(\"0123456789\", ch);\r\n  let [inString, line, col, inStringAt] = [false, 1, 0, [1, 0]];\r\n  let [inSymbol, inNumber, inHex] = [false, false, false];\r\n  for (let i = 0, l = slen(code); i < l; ++i) {\r\n    const c = strIdx(code, i),\r\n      nextCh = i + 1 !== l ? strIdx(code, i + 1) : \"\";\r\n    ++col;\r\n    if (c === \"\\\\\" && inString) {\r\n      tokens[len(tokens) - 1].text += doTransforms\r\n        ? { n: \"\\n\", t: \"\\t\", r: \"\\r\", '\"': '\"' }[nextCh] ||\r\n          (nextCh === \"\\\\\" ? \"\\\\\" : `\\\\${nextCh}`)\r\n        : `\\\\${nextCh}`;\r\n      ++col;\r\n      ++i;\r\n      continue;\r\n    }\r\n    const errCtx: ErrCtx = { invokeId, line, col };\r\n    if (c === '\"') {\r\n      if ((inString = !inString)) {\r\n        inStringAt = [line, col];\r\n        tokens.push({ typ: \"str\", text: \"\", errCtx });\r\n      }\r\n      inNumber = inSymbol = false;\r\n      continue;\r\n    }\r\n    const isWhite = sub(\" \\t\\n\\r,\", c);\r\n    if (!inString && isWhite) {\r\n      inSymbol = false;\r\n      inNumber &&= c === \",\";\r\n      if (c === \"\\n\") {\r\n        ++line;\r\n        col = 0;\r\n      }\r\n      continue;\r\n    }\r\n    if (!inString && c === \";\") {\r\n      const nl = subIdx(substr(code, ++i), \"\\n\");\r\n      const text = substr(code, i, nl > 0 ? nl : l - i);\r\n      i += slen(text);\r\n      ++line;\r\n      col = 0;\r\n      if (emitComments) {\r\n        tokens.push({ typ: \"rem\", text, errCtx });\r\n      }\r\n      continue;\r\n    }\r\n    const isParen = sub(\"()[]{}\", c);\r\n    //Allow one . per number, or hex, or binary, else convert into symbol\r\n    if (inNumber && !isDigit(c)) {\r\n      const hexStart = c === \"x\" && tokens[len(tokens) - 1].text === \"0\";\r\n      inHex = inHex || hexStart;\r\n      inNumber =\r\n        (c === \"b\" && tokens[len(tokens) - 1].text === \"0\") ||\r\n        (c === \".\" && !sub(tokens[len(tokens) - 1].text, \".\")) ||\r\n        (inHex && (hexStart || sub(\"ABCDEFabcdef\", c)));\r\n      if (!inNumber && !isParen && !isWhite) {\r\n        inSymbol = true;\r\n        tokens[len(tokens) - 1].typ = \"sym\";\r\n      }\r\n    }\r\n    //Stop scanning symbol if a paren\r\n    if (inSymbol && isParen) {\r\n      inSymbol = false;\r\n    }\r\n    //If we just finished concatenating a token\r\n    if (!inString && !inSymbol && !inNumber) {\r\n      if (isParen) {\r\n        const text = subIdx(\"[{(\", c) === -1 ? \")\" : \"(\";\r\n        tokens.push({ typ: text, text: doTransforms ? text : c, errCtx });\r\n        if (doTransforms && (c === \"[\" || c === \"{\")) {\r\n          tokens.push({ typ: \"sym\", text: c === \"[\" ? \"vec\" : \"dict\", errCtx });\r\n        }\r\n        continue;\r\n      }\r\n      inNumber =\r\n        isDigit(c) ||\r\n        (c === \".\" && isDigit(nextCh)) ||\r\n        (c === \"-\" && (isDigit(nextCh) || nextCh === \".\"));\r\n      inHex = inSymbol = !inNumber;\r\n      const typ: Token[\"typ\"] = inSymbol ? \"sym\" : \"num\";\r\n      tokens.push({ typ, text: \"\", errCtx });\r\n    }\r\n    tokens[len(tokens) - 1].text += c;\r\n  }\r\n  return { tokens, stringError: inString ? inStringAt : undefined };\r\n}\r\n\r\n/** Parses tokens into a tree where each node is a token or token list. */\r\nfunction treeise(tokens: Token[]): Node[] {\r\n  const nodes: Node[] = [];\r\n  const _treeise = (tokens: Token[]): Node => {\r\n    let prefix: Token | undefined;\r\n    if (tokens[0].typ === \"sym\" && sub(\"@#\", tokens[0].text)) {\r\n      prefix = tokens.shift()!;\r\n    }\r\n    const token = tokens.shift()!;\r\n    if (token.typ !== \"(\" && token.typ !== \")\") {\r\n      return token;\r\n    }\r\n    const nodes: Node[] = prefix ? [prefix] : [];\r\n    while (tokens[0].typ !== \")\") {\r\n      nodes.push(_treeise(tokens));\r\n    }\r\n    tokens.shift();\r\n    return nodes;\r\n  };\r\n  while (len(tokens)) {\r\n    nodes.push(_treeise(tokens));\r\n  }\r\n  return nodes;\r\n}\r\n\r\n/** Separates function nodes and non-function nodes,\r\n * with non-function nodes collected into (function entry ...)\r\n * if there are any.*/\r\nfunction collectFuncs(\r\n  nodes: Node[],\r\n): ({ name: string; nodes: Node[] } | { err: string; errCtx: ErrCtx })[] {\r\n  const funcs: ReturnType<typeof collectFuncs> = [];\r\n  const entries: Node[] = [];\r\n  nodes.forEach(node => {\r\n    if (!isToken(node) && isToken(node[0]) && symAt(node) === \"function\") {\r\n      const name = symAt(node, 1);\r\n      if (!name) {\r\n        funcs.push({ err: \"nameless function\", errCtx: node[0].errCtx });\r\n      } else if (len(node) < 3) {\r\n        funcs.push({ err: \"empty function body\", errCtx: node[0].errCtx });\r\n      }\r\n      funcs.push({ name, nodes: slice(node, 2) });\r\n    } else {\r\n      entries.push(node);\r\n    }\r\n  });\r\n  if (len(entries)) {\r\n    funcs.push({ name: \"entry\", nodes: entries });\r\n  }\r\n  return funcs;\r\n}\r\n\r\nconst parseNode = (node: Node, params: ParamsShape) =>\r\n  isToken(node) ? parseArg(node, params) : parseForm(node, params);\r\n\r\nfunction parseForm(\r\n  nodes: Node[],\r\n  params: ParamsShape,\r\n  doArityCheck = true,\r\n): ParserIns[] {\r\n  if (!len(nodes)) {\r\n    return [];\r\n  }\r\n  const nodeParser = (node: Node) => parseNode(node, params);\r\n  let firstNode = nodes.shift()!;\r\n  let head = nodeParser(firstNode);\r\n  const { errCtx } = head[0];\r\n  if (isToken(firstNode) && firstNode.typ === \"sym\") {\r\n    //1-off arity deficiency rewritten as closure\r\n    if (firstNode.text in ops) {\r\n      const { exactArity, minArity } = ops[firstNode.text];\r\n      const a = exactArity ?? minArity;\r\n      if (a && a !== 1 && len(nodes) + 1 === a) {\r\n        nodes.unshift(firstNode);\r\n        firstNode = { typ: \"sym\", text: \"@\", errCtx: firstNode.errCtx };\r\n      }\r\n    }\r\n    if (has([\"var\", \"let\"], firstNode.text) && len(nodes) && len(nodes) % 2) {\r\n      nodes.unshift(firstNode);\r\n      nodes.push({ typ: \"sym\", text: \"%\", errCtx: firstNode.errCtx });\r\n      firstNode = { typ: \"sym\", text: \"#\", errCtx: firstNode.errCtx };\r\n    }\r\n    const { text: op, errCtx } = firstNode;\r\n    const err = (m: string, eCtx = errCtx) => [\r\n      <ParserIns>{ typ: \"err\", value: m, errCtx: eCtx },\r\n    ];\r\n\r\n    if (has([\"if\", \"if!\", \"when\", \"unless\", \"match\"], op) && !len(nodes)) {\r\n      return err(\"provide a condition\");\r\n    } else if (has([\"if\", \"if!\"], op)) {\r\n      if (len(nodes) === 1) {\r\n        return err(\"provide at least one branch\");\r\n      } else if (len(nodes) > 3) {\r\n        return err(`provide one or two branches, not ${len(nodes)}`);\r\n      }\r\n      const parsed = nodes.map(nodeParser);\r\n      const [cond, branch1] = parsed;\r\n      let branch2 = parsed[2];\r\n      const ifN = op === \"if!\" && [\r\n        <Ins>{ typ: \"val\", value: { t: \"func\", v: \"!\" }, errCtx },\r\n        <Ins>{ typ: \"exe\", value: 1, errCtx },\r\n      ];\r\n      if (!branch2) {\r\n        branch2 = [{ typ: \"val\", value: nullVal, errCtx }];\r\n      }\r\n      return [\r\n        ...cond,\r\n        ...(ifN || []),\r\n        { typ: \"if\", value: len(branch1) + 1, errCtx },\r\n        ...branch1,\r\n        { typ: \"jmp\", value: len(branch2), errCtx },\r\n        ...branch2,\r\n      ];\r\n    } else if (op === \"when\" || op === \"unless\") {\r\n      if (len(nodes) === 1) {\r\n        return err(\"provide a body\");\r\n      }\r\n      const parsed = nodes.map(nodeParser);\r\n      const [cond, body] = [parsed[0], slice(parsed, 1)];\r\n      const bodyIns = poppedBody(body);\r\n      return [\r\n        ...cond,\r\n        ...(op === \"unless\"\r\n          ? [\r\n              <Ins>{ typ: \"val\", value: { t: \"func\", v: \"!\" } },\r\n              <Ins>{ typ: \"exe\", value: 1 },\r\n            ]\r\n          : []),\r\n        { typ: \"if\", value: len(bodyIns) + 1, errCtx },\r\n        ...bodyIns,\r\n        { typ: \"jmp\", value: 1, errCtx },\r\n        { typ: \"val\", value: nullVal, errCtx },\r\n      ];\r\n    } else if (op === \"match\") {\r\n      const parsed = nodes.map(nodeParser);\r\n      const [cond, args] = [parsed[0], slice(parsed, 1)];\r\n      const otherwise: ParserIns[] = len(args) % 2 ? args.pop()! : [];\r\n      if (!len(args)) {\r\n        return err(\"provide at least one case\");\r\n      }\r\n      const elseLen = len(otherwise);\r\n      let insCount =\r\n        args.reduce((acc, a) => acc + len(a), 0) +\r\n        (elseLen ? elseLen : 2) +\r\n        len(args);\r\n      const ins: ParserIns[] = cond;\r\n      while (len(args) > 1) {\r\n        const [a, when] = [args.shift()!, args.shift()!];\r\n        push(ins, a);\r\n        ins.push({ typ: \"mat\", value: len(when) + 1, errCtx });\r\n        push(ins, when);\r\n        insCount -= len(a) + len(when) + 2;\r\n        ins.push({ typ: \"jmp\", value: insCount, errCtx });\r\n      }\r\n      if (len(otherwise)) {\r\n        push(ins, otherwise);\r\n      } else {\r\n        ins.push({ typ: \"pop\", value: 1, errCtx });\r\n        ins.push({ typ: \"val\", value: falseVal, errCtx });\r\n      }\r\n      return ins;\r\n    } else if (op === \"catch\") {\r\n      if (len(nodes) < 2) {\r\n        return err(\"provide at least 2 arguments\");\r\n      }\r\n      const when = nodeParser(nodes.pop()!);\r\n      const body = flat(nodes.map(nodeParser));\r\n      return [...body, { typ: \"cat\", value: len(when), errCtx }, ...when];\r\n    } else if (op === \"and\" || op === \"or\" || op === \"while\") {\r\n      const args = nodes.map(nodeParser);\r\n      if (len(args) < 2) {\r\n        return err(\"provide at least 2 arguments\");\r\n      }\r\n      const ins: ParserIns[] = [];\r\n      if (op === \"while\") {\r\n        const [head, body] = [args[0], slice(args, 1)];\r\n        const flatBody = poppedBody(body);\r\n        const ifJmp = len(flatBody) + 2;\r\n        const looJmp = -(len(head) + len(flatBody) + 3);\r\n        ins.push({ typ: \"val\", value: nullVal, errCtx });\r\n        push(ins, head);\r\n        ins.push({ typ: \"if\", value: ifJmp, errCtx });\r\n        ins.push({ typ: \"pop\", value: 1, errCtx });\r\n        push(ins, flatBody);\r\n        ins.push({ typ: \"loo\", value: looJmp, errCtx });\r\n        return ins;\r\n      }\r\n      let insCount = args.reduce((acc, a) => acc + len(a), 0);\r\n      insCount += len(args); //+1 for each if/or ins\r\n      insCount += toNum(op === \"and\");\r\n      const typ = op === \"and\" ? \"if\" : \"or\";\r\n      for (let a = 0; a < len(args); ++a) {\r\n        push(ins, args[a]);\r\n        insCount -= len(args[a]);\r\n        ins.push({ typ, value: insCount, errCtx });\r\n        --insCount;\r\n      }\r\n      if (op === \"and\") {\r\n        push(ins, [\r\n          { typ: \"val\", value: <Val>{ t: \"bool\", v: true }, errCtx },\r\n          { typ: \"jmp\", value: 1, errCtx },\r\n        ]);\r\n      }\r\n      ins.push({ typ: \"val\", value: falseVal, errCtx });\r\n      return ins;\r\n    } else if (op === \"loop\") {\r\n      if (len(nodes) < 3) {\r\n        return err(\"provide at least 3 arguments\");\r\n      }\r\n      const parsed = nodes.map(nodeParser);\r\n      const symNode = nodes[1];\r\n      const body = poppedBody(slice(parsed, 2));\r\n      if (!isToken(symNode)) {\r\n        return err(\"argument 2 must be symbol\");\r\n      }\r\n      //(let sym 0 sym-limit n) ... body ... (if (< (let sym (inc sym)) sym-limit) <exit> <loo>)\r\n      const ins: ParserIns[] = [\r\n        { typ: \"val\", value: { t: \"num\", v: 0 }, errCtx },\r\n        { typ: \"let\", value: symNode.text, errCtx },\r\n        ...parsed[0],\r\n        { typ: \"let\", value: symNode.text + \"-limit\", errCtx },\r\n        { typ: \"pop\", value: 1, errCtx },\r\n        ...body,\r\n        { typ: \"ref\", value: symNode.text, errCtx },\r\n        { typ: \"val\", value: { t: \"func\", v: \"inc\" }, errCtx },\r\n        { typ: \"exe\", value: 1, errCtx },\r\n        { typ: \"let\", value: symNode.text, errCtx },\r\n        { typ: \"ref\", value: symNode.text + \"-limit\", errCtx },\r\n        { typ: \"val\", value: { t: \"func\", v: \"<\" }, errCtx },\r\n        { typ: \"exe\", value: 2, errCtx },\r\n        { typ: \"if\", value: 2, errCtx },\r\n        { typ: \"pop\", value: 1, errCtx },\r\n        { typ: \"loo\", value: -(len(body) + 10), errCtx },\r\n      ];\r\n      return ins;\r\n    } else if (op === \"var\" || op === \"let\") {\r\n      const defs = nodes.filter((n, i) => !(i % 2));\r\n      const vals = nodes.filter((n, i) => !!(i % 2));\r\n      if (!len(defs)) {\r\n        return err(\"provide at least 1 declaration name and value\");\r\n      } else if (len(defs) > len(vals)) {\r\n        return err(\"provide a value after each declaration name\");\r\n      }\r\n      const ins: ParserIns[] = [];\r\n      const symErrMsg = `${op} name must be a new symbol or destructuring`;\r\n      for (let d = 0, lim = len(defs); d < lim; ++d) {\r\n        push(ins, nodeParser(vals[d]));\r\n        const def = defs[d];\r\n        if (isToken(def)) {\r\n          const defIns = parseNode(defs[d], params);\r\n          if (len(defIns) > 1 || defIns[0].typ !== \"ref\") {\r\n            return err(symErrMsg, defIns[0].errCtx);\r\n          }\r\n          ins.push({ typ: op, value: defIns[0].value, errCtx });\r\n        } else {\r\n          const { shape, errors } = parseParams([def], true);\r\n          if (len(errors)) {\r\n            return errors;\r\n          }\r\n          if (!len(shape)) {\r\n            return err(symErrMsg);\r\n          }\r\n          const typ = op === \"var\" ? \"dva\" : \"dle\";\r\n          ins.push({ typ, value: shape, errCtx });\r\n        }\r\n      }\r\n      return ins;\r\n    } else if (op === \"var!\" || op === \"let!\") {\r\n      //Rewrite e.g. (var! a + 1) -> (var a (+ a 1))\r\n      if (len(nodes) < 2) {\r\n        return err(\"provide 1 declaration name and 1 function\");\r\n      }\r\n      const parsed = nodes.map(nodeParser);\r\n      const [def, func, args] = [parsed[0][0], parsed[1], slice(parsed, 2)];\r\n      if (def.typ !== \"ref\") {\r\n        return err(\"declaration name must be symbol\", def.errCtx);\r\n      }\r\n      const ins: Ins[] = [{ typ: \"ref\", value: def.value, errCtx }];\r\n      push(ins, [...flat(args), ...func]);\r\n      ins.push({ typ: \"exe\", value: len(args) + 1, errCtx });\r\n      const typ = op === \"var!\" ? \"var\" : \"let\";\r\n      ins.push({ typ, value: def.value, errCtx });\r\n      return ins;\r\n    } else if (op === \"#\" || op === \"@\" || op === \"fn\") {\r\n      const pins: ParserIns[] = [];\r\n      const name = node2str([firstNode, ...nodes]);\r\n      const cloParams: string[] = [];\r\n      let monoFnBody = false;\r\n      if (op === \"fn\") {\r\n        const parsedParams = parseParams(nodes, false);\r\n        push(\r\n          cloParams,\r\n          parsedParams.shape.map(p => p.name),\r\n        );\r\n        params = parsedParams.shape;\r\n        push(pins, parsedParams.errors);\r\n        if (!len(nodes)) {\r\n          return err(\"provide a body\");\r\n        }\r\n        monoFnBody = len(nodes) === 1;\r\n        nodes.unshift({ typ: \"sym\", text: \"do\", errCtx });\r\n      }\r\n      //Rewrite partial closure to #(... [body] args)\r\n      if (op === \"@\") {\r\n        const firstSym = symAt(nodes, 0);\r\n        if (has(syntaxes, firstSym)) {\r\n          const { errCtx } = nodes[0] as Token;\r\n          return err(\r\n            `\"${firstSym}\" syntax unavailable in partial closure`,\r\n            errCtx,\r\n          );\r\n        }\r\n        nodes = [\r\n          { typ: \"sym\", text: \"...\", errCtx },\r\n          ...nodes,\r\n          { typ: \"sym\", text: \"args\", errCtx },\r\n        ];\r\n      }\r\n      push(pins, parseForm(nodes, params, op !== \"@\"));\r\n      const cins = <Ins[]>pins.filter(i => i.typ !== \"err\");\r\n      const errors = pins.filter(i => i.typ === \"err\");\r\n      if (len(errors)) {\r\n        return errors;\r\n      }\r\n      //Remove do exe when fn body is only one expression\r\n      if (monoFnBody) {\r\n        cins.pop();\r\n        cins.pop();\r\n      }\r\n      return [\r\n        { typ: \"clo\", value: makeClosure(name, cloParams, cins), errCtx },\r\n        ...cins,\r\n      ];\r\n    }\r\n\r\n    //Operation arity check, optionally disabled for partial closures\r\n    if (ops[op] && doArityCheck) {\r\n      const errors = arityCheck(op, len(nodes), errCtx);\r\n      const err = (value: string, eCtx = errCtx) => [\r\n        <ParserIns>{ typ: \"err\", value, errCtx: eCtx },\r\n      ];\r\n      push(head, errors?.map(e => err(e.m)[0]) ?? []);\r\n      if (!errors) {\r\n        //Upgrade some math and logic functions to their faster counterparts\r\n        if (len(nodes) === 2 && ops[`fast${op}`]) {\r\n          head = nodeParser({ typ: \"sym\", text: `fast${op}`, errCtx });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const args = nodes.map(nodeParser);\r\n  const ins: ParserIns[] = flat(args);\r\n  if (symAt([firstNode]) === \"return\") {\r\n    return [...ins, { typ: \"ret\", value: !!len(args), errCtx }];\r\n  } else if (head[0].typ === \"ref\") {\r\n    const { value: v, errCtx } = head[0];\r\n    head[0] = { typ: \"val\", value: { t: \"str\", v }, errCtx };\r\n  }\r\n  push(ins, head);\r\n  const typ = len(head) > 1 || has([\"npa\", \"upa\"], head[0].typ) ? \"exa\" : \"exe\";\r\n  return [...ins, { typ, value: len(args), errCtx }];\r\n}\r\n\r\nfunction parseArg(node: Node, params: ParamsShape): ParserIns[] {\r\n  if (isToken(node)) {\r\n    const { errCtx } = node;\r\n    if (node.typ === \"str\") {\r\n      return [{ typ: \"val\", value: { t: \"str\", v: node.text }, errCtx }];\r\n    } else if (node.typ === \"num\") {\r\n      return [{ typ: \"val\", value: { t: \"num\", v: toNum(node.text) }, errCtx }];\r\n    } else if (node.typ === \"sym\") {\r\n      const { text } = node;\r\n      const paramNames = params.map(({ name }) => name);\r\n      if (text === \"true\" || text === \"false\") {\r\n        return [\r\n          { typ: \"val\", value: <Val>{ t: \"bool\", v: text === \"true\" }, errCtx },\r\n        ];\r\n      } else if (text === \"null\") {\r\n        return [{ typ: \"val\", value: nullVal, errCtx }];\r\n      } else if (text === \"_\") {\r\n        return [{ typ: \"val\", value: { t: \"wild\", v: undefined }, errCtx }];\r\n      } else if (starts(text, \":\")) {\r\n        return [{ typ: \"val\", value: <Val>{ t: \"key\", v: text }, errCtx }];\r\n      } else if (\r\n        text === \"%\" ||\r\n        (starts(text, \"%\") && isNum(substr(text, 1)))\r\n      ) {\r\n        const value = text === \"%\" ? 0 : toNum(substr(text, 1));\r\n        if (value < 0) {\r\n          return [{ typ: \"val\", value: nullVal, errCtx }];\r\n        }\r\n        return [{ typ: \"upa\", value, text, errCtx }];\r\n      } else if (has(paramNames, text)) {\r\n        const param = params.find(({ name }) => name === text)!;\r\n        if (len(param.position) === 1) {\r\n          return [{ typ: \"npa\", value: param.position[0], text, errCtx }];\r\n        }\r\n        return [{ typ: \"dpa\", value: param.position, errCtx }];\r\n      } else if (text === \"args\") {\r\n        return [{ typ: \"upa\", value: -1, text: \"args\", errCtx }];\r\n      } else if (text === \"PI\" || text === \"E\") {\r\n        const v = text === \"PI\" ? 3.141592653589793 : 2.718281828459045;\r\n        return [{ typ: \"val\", value: { t: \"num\", v }, errCtx }];\r\n      } else if (ops[text]) {\r\n        return [{ typ: \"val\", value: <Val>{ t: \"func\", v: text }, errCtx }];\r\n      }\r\n      return [{ typ: \"ref\", value: text, errCtx }];\r\n    }\r\n    return [];\r\n  } else if (!len(node)) {\r\n    return [];\r\n  }\r\n  return parseForm(node, params);\r\n}\r\n\r\n/** Consumes some tokens and returns ParamsShape.\r\n * Example inputs:\r\n * \"(fn \"   a [b [c]] d [d c b a]\r\n * \"(var \" [a] [1 2] b [1 2]\r\n * \"(function \" [x] (print x) x\r\n * \"(function \" x [x]\r\n * \"(fn \"\r\n * \"(function \"\r\n * */\r\nfunction parseParams(\r\n  nodes: Node[],\r\n  consumeLast: boolean,\r\n  position: number[] = [],\r\n): { shape: ParamsShape; errors: ParserIns[] } {\r\n  const shape: ParamsShape = [],\r\n    errs: ParserIns[] = [];\r\n  let n = 0;\r\n  while (\r\n    len(nodes) > (consumeLast ? 0 : 1) &&\r\n    (isToken(nodes[0]) || symAt(nodes[0]) === \"vec\")\r\n  ) {\r\n    const param = nodes.shift()!;\r\n    if (!isToken(param)) {\r\n      param.shift();\r\n      const parsed = parseParams(param, true, [...position, n]);\r\n      push(shape, parsed.shape);\r\n      push(errs, parsed.errors);\r\n    } else {\r\n      const { typ, errCtx } = param;\r\n      if (typ === \"sym\") {\r\n        shape.push({ name: param.text, position: [...position, n] });\r\n      } else {\r\n        errs.push({ typ: \"err\", value: \"provide parameter name\", errCtx });\r\n      }\r\n    }\r\n    ++n;\r\n  }\r\n  return { shape, errors: errs };\r\n}\r\n\r\nfunction compileFunc({ name, nodes: nodes }: NamedNodes): Func | InvokeError {\r\n  const { shape: params, errors } = parseParams(nodes, false);\r\n  const ins = [...errors, ...flat(nodes.map(node => parseArg(node, params)))];\r\n  for (let i = 0, lim = len(ins); i < lim; i++) {\r\n    const { typ, value, errCtx } = ins[i];\r\n    if (typ === \"err\") {\r\n      return <InvokeError>{ e: \"Parse\", m: value, errCtx };\r\n    }\r\n  }\r\n  return { name, ins: <Ins[]>ins };\r\n}\r\n\r\nfunction findParenImbalance(\r\n  tokens: Token[],\r\n  numL: number,\r\n  numR: number,\r\n): [number, number] {\r\n  //Scan for first instance of untimely closed\r\n  //  or last instance of unclosed open\r\n  const untimely = numR >= numL;\r\n  const [l, r] = [untimely ? \"(\" : \")\", untimely ? \")\" : \"(\"];\r\n  const direction = untimely ? 1 : -1;\r\n  for (\r\n    let lim = len(tokens), t = untimely ? 0 : lim - 1, depth = 0;\r\n    untimely ? t < lim : t >= 0;\r\n    t += direction\r\n  ) {\r\n    const {\r\n      typ,\r\n      errCtx: { line, col },\r\n    } = tokens[t];\r\n    depth += toNum(typ === l) - toNum(typ === r);\r\n    if (depth < 0) {\r\n      return [line, col];\r\n    }\r\n  }\r\n  return [0, 0];\r\n}\r\n\r\nfunction tokenErrorDetect(stringError: number[] | undefined, tokens: Token[]) {\r\n  const invokeId = len(tokens) ? tokens[0].errCtx.invokeId : \"\";\r\n  const errors: InvokeError[] = [];\r\n  const err = (m: string, errCtx: ErrCtx) =>\r\n    errors.push({ e: \"Parse\", m, errCtx });\r\n\r\n  //Check for double-quote imbalance\r\n  if (stringError) {\r\n    const [line, col] = stringError;\r\n    err(\"unmatched double quotation marks\", { invokeId, line, col });\r\n    return errors;\r\n  }\r\n\r\n  //Check for paren imbalance\r\n  const countTyp = (t: Token[\"typ\"]) =>\r\n    len(tokens.filter(({ typ }) => typ === t));\r\n  const [numL, numR] = [countTyp(\"(\"), countTyp(\")\")];\r\n  {\r\n    const [line, col] = findParenImbalance(tokens, numL, numR);\r\n    if (line + col) {\r\n      err(\"unmatched parenthesis\", { invokeId: invokeId, line, col });\r\n    }\r\n  }\r\n\r\n  //Check for any empty expressions\r\n  let emptyHead: Token | undefined;\r\n  for (let t = 0, lastWasL = false; t < len(tokens); ++t) {\r\n    if (lastWasL && tokens[t].typ === \")\") {\r\n      emptyHead = tokens[t];\r\n      break;\r\n    }\r\n    lastWasL = tokens[t].typ === \"(\";\r\n  }\r\n  if (emptyHead) {\r\n    err(\"empty expression forbidden\", emptyHead.errCtx);\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\n//TODO: investigate Node implementation replacement\r\nfunction insErrorDetect(fins: Ins[]): InvokeError[] | undefined {\r\n  type TypeInfo = {\r\n    types?: Val[\"t\"][];\r\n    val?: Val;\r\n  };\r\n  const stack: TypeInfo[] = [];\r\n  for (let i = 0, lim = len(fins); i < lim; ++i) {\r\n    const ins = fins[i];\r\n    switch (ins.typ) {\r\n      case \"val\":\r\n        stack.push({ types: [ins.value.t], val: ins.value });\r\n        break;\r\n      case \"exa\":\r\n      case \"exe\": {\r\n        const head = stack.pop()!;\r\n        const args = splice(stack, len(stack) - ins.value, ins.value);\r\n        const badMatch = (okTypes: Val[\"t\"][]) =>\r\n          args.findIndex(\r\n            ({ types }) => types && !okTypes.find(t => has(types, t)),\r\n          );\r\n        const headIs = (t: Val[\"t\"]) =>\r\n          head.val\r\n            ? head.val.t === t\r\n            : head.types && len(head.types) === 1 && head.types[0] === t;\r\n        if (head.val && head.val.t === \"func\") {\r\n          if (head.val.v === \"recur\") {\r\n            splice(stack, len(stack) - ins.value, ins.value);\r\n            break;\r\n          }\r\n          const errors = typeCheck(\r\n            head.val.v,\r\n            args.map(a => a.types ?? []),\r\n            ins.errCtx,\r\n            true,\r\n          );\r\n          if (errors) {\r\n            return errors;\r\n          }\r\n          const { returns, numeric: onlyNum } = ops[head.val.v];\r\n          stack.push(\r\n            onlyNum && onlyNum !== \"in only\"\r\n              ? { types: [\"num\"] }\r\n              : { types: returns },\r\n          );\r\n        } else if (headIs(\"num\")) {\r\n          const badArg = badMatch([\"str\", \"dict\", \"vec\"]);\r\n          if (badArg !== -1) {\r\n            return numOpErr(ins.errCtx, args[badArg].types!);\r\n          }\r\n          stack.push({});\r\n        } else if (headIs(\"key\")) {\r\n          const badArg = badMatch([\"dict\", \"vec\"]);\r\n          if (badArg !== -1) {\r\n            return keyOpErr(ins.errCtx, args[badArg].types!);\r\n          }\r\n          stack.push({});\r\n        } else if (headIs(\"str\") || headIs(\"bool\")) {\r\n          stack.push({});\r\n        } else if (!head.types && !head.val) {\r\n          stack.push({});\r\n        }\r\n        break;\r\n      }\r\n      case \"or\":\r\n        stack.pop();\r\n        stack.push({});\r\n        i += ins.value;\r\n        break;\r\n      case \"cat\":\r\n      case \"var\":\r\n      case \"let\":\r\n      case \"dva\":\r\n      case \"dle\":\r\n      case \"loo\":\r\n      case \"jmp\":\r\n        break;\r\n      case \"clo\": {\r\n        const errors = insErrorDetect(slice(fins, i + 1, i + ins.value.length));\r\n        if (errors) {\r\n          return errors;\r\n        }\r\n        stack.push({});\r\n      }\r\n      case \"ref\":\r\n      case \"npa\":\r\n      case \"upa\":\r\n      case \"dpa\":\r\n        stack.push({});\r\n        break;\r\n      case \"if\": {\r\n        stack.pop();\r\n        stack.push({});\r\n        const ifIns = slice(fins, i + 1, ins.value + 1);\r\n        const errors = insErrorDetect(ifIns);\r\n        if (errors) {\r\n          return errors;\r\n        }\r\n        i += ins.value - 1;\r\n        break;\r\n      }\r\n      case \"mat\": {\r\n        stack.pop(); //first match\r\n        stack.pop(); //cond\r\n        i += ins.value;\r\n        i += fins[i].value as number; //The first jmp\r\n        stack.push({});\r\n        break;\r\n      }\r\n      case \"pop\":\r\n        splice(stack, len(stack) - ins.value, ins.value);\r\n        break;\r\n      case \"ret\":\r\n        if (ins.value) {\r\n          stack.pop();\r\n        }\r\n        break;\r\n      default:\r\n        assertUnreachable(ins);\r\n    }\r\n  }\r\n}\r\n\r\nexport function parse(\r\n  code: string,\r\n  invokeId: string,\r\n): { funcs: Funcs; errors: InvokeError[] } {\r\n  const { tokens, stringError } = tokenise(code, invokeId);\r\n  const tokenErrors = tokenErrorDetect(stringError, tokens);\r\n  if (len(tokenErrors)) {\r\n    return { errors: tokenErrors, funcs: {} };\r\n  }\r\n  const okFuncs: Func[] = [],\r\n    errors: InvokeError[] = [];\r\n  const tree = treeise(slice(tokens));\r\n  const collected = collectFuncs(tree);\r\n  const namedNodes: NamedNodes[] = [];\r\n  collected.forEach(nodeOrErr => {\r\n    if (\"err\" in nodeOrErr) {\r\n      errors.push({ e: \"Parse\", m: nodeOrErr.err, errCtx: nodeOrErr.errCtx });\r\n    } else {\r\n      namedNodes.push({ name: nodeOrErr.name, nodes: nodeOrErr.nodes });\r\n    }\r\n  });\r\n  namedNodes.map(compileFunc).forEach(fae => {\r\n    if (\"e\" in fae) {\r\n      errors.push(fae);\r\n    } else {\r\n      okFuncs.push(fae);\r\n    }\r\n  });\r\n  push(errors, flat(okFuncs.map(f => insErrorDetect(f.ins) ?? [])));\r\n  const funcs: Funcs = {};\r\n  okFuncs.forEach(func => (funcs[func.name ?? \"\"] = func));\r\n  return { errors, funcs };\r\n}\r\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","toNum","x","Number","arr","start","end","slice","splice","numDel","length","slen","str","isNum","isNaN","Array","isArray","substr","substring","strIdx","idx","sub","s","includes","subIdx","indexOf","y","starts","prefix","startsWith","ends","endsWith","replace","what","to","RegExp","flat","concat","a","b","add","push","sortBy","by","sort","reverse","lowerCase","toLowerCase","upperCase","toUpperCase","trim","trimStart","trimEnd","padEnd","charCode","charCodeAt","codeChar","num","String","fromCharCode","randNum","Math","random","randInt","floor","range","keys","objKeys","getTimeMs","Date","getTime","abs","min","max","sin","cos","tan","sinh","cosh","tanh","asin","acos","atan","sqrt","round","ceil","sign","logn","log","log2","log10","has","len","tokenise","code","invokeId","doTransforms","emitComments","tokens","isDigit","ch","inString","line","col","inStringAt","inSymbol","inNumber","inHex","i","l","c","nextCh","text","n","t","r","errCtx","typ","isWhite","nl","isParen","hexStart","stringError"],"sourceRoot":""}